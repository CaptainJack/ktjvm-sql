package ru.capjack.tool.sql

import org.intellij.lang.annotations.Language
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Statement

inline fun <R> Connection.transaction(block: Connection.() -> R): R {
	val a = autoCommit
	autoCommit = false
	try {
		val r = block()
		commit()
		return r
	}
	catch (e: Throwable) {
		rollback()
		throw e
	}
	finally {
		autoCommit = a
	}
}

fun Connection.prepareAddableStatement(@Language("SQL") sql: String): AddablePreparedStatement {
	return AddablePreparedStatementImpl(prepareStatement(sql))
}

fun Connection.prepareAddableStatement(@Language("SQL") sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): AddablePreparedStatement {
	return AddablePreparedStatementImpl(prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability))
}

fun Connection.prepareAddableStatement(@Language("SQL") sql: String, autoGeneratedKeys: Int): AddablePreparedStatement {
	return AddablePreparedStatementImpl(prepareStatement(sql, autoGeneratedKeys))
}

fun Connection.prepareAddableStatement(@Language("SQL") sql: String, columnIndexes: IntArray): AddablePreparedStatement {
	return AddablePreparedStatementImpl(prepareStatement(sql, columnIndexes))
}

fun Connection.prepareAddableStatement(@Language("SQL") sql: String, columnNames: Array<String>): AddablePreparedStatement {
	return AddablePreparedStatementImpl(prepareStatement(sql, columnNames))
}


// Fetch

inline fun <R> Connection.fetch(@Language("SQL") sql: String, result: ResultSet.() -> R): R {
	createStatement().use {
		it.executeQuery(sql).use { rs ->
			return rs.result()
		}
	}
}

inline fun Connection.fetchIterate(@Language("SQL") sql: String, action: ResultSet.() -> Unit) {
	fetch(sql) {
		while (next()) {
			action()
		}
	}
}

inline fun <E> Connection.fetchList(@Language("SQL") sql: String, transform: ResultSet.() -> E): List<E> {
	val list = mutableListOf<E>()
	fetchIterate(sql) {
		list.add(transform())
	}
	return list
}

inline fun <K, V> Connection.fetchMap(@Language("SQL") sql: String, transform: ResultSet.() -> Pair<K, V>): Map<K, V> {
	val map = mutableMapOf<K, V>()
	fetchIterate(sql) {
		val (key, value) = transform()
		map[key] = value
		
	}
	return map
}

inline fun <K, V> Connection.fetchMapGroup(@Language("SQL") sql: String, transform: ResultSet.() -> Pair<K, V>): Map<K, List<V>> {
	val map = mutableMapOf<K, MutableList<V>>()
	fetchIterate(sql) {
		val (key, value) = transform()
		map.getOrPut(key) { mutableListOf() }.add(value)
	}
	return map
}

inline fun <R> Connection.fetchFirstOrElse(@Language("SQL") sql: String, result: ResultSet.() -> R, other: () -> R): R {
	fetch(sql) {
		return if (next()) result() else other()
	}
}

inline fun <R> Connection.fetchFirst(@Language("SQL") sql: String, result: ResultSet.() -> R): R {
	return fetchFirstOrElse(sql, result) {
		throw SQLException("Query has empty result")
	}
}

fun Connection.fetchExists(@Language("SQL") sql: String): Boolean {
	return fetchFirstOrElse(sql, { true }, { false })
}


// Put

fun Connection.put(@Language("SQL") sql: String): Int {
	val rows = putMaybe(sql)
	if (rows == 0) {
		throw SQLException("Update has not made any changes")
	}
	return rows
}

fun Connection.putMaybe(@Language("SQL") sql: String): Int {
	createStatement().use {
		return it.executeUpdate(sql)
	}
}

inline fun Connection.putOrElse(@Language("SQL") sql: String, other: () -> Unit) {
	if (0 == putMaybe(sql)) {
		other()
	}
}


fun Connection.putAndGetGeneratedKeyInt(@Language("SQL") sql: String): Int {
	return putAndGetGeneratedKeysOrElse(sql, { getInt(1) }, { throw SQLException("Update has not made any changes") })
}

fun Connection.putAndGetGeneratedKeyLong(@Language("SQL") sql: String): Long {
	return putAndGetGeneratedKeysOrElse(sql, { getLong(1) }, { throw SQLException("Update has not made any changes") })
}


fun Connection.putAndGetGeneratedKeyIntMaybe(@Language("SQL") sql: String): Int? {
	return putAndGetGeneratedKeysOrElse(sql, { getInt(1) }, { null })
}

fun Connection.putAndGetGeneratedKeyLongMaybe(@Language("SQL") sql: String): Long? {
	return putAndGetGeneratedKeysOrElse(sql, { getLong(1) }, { null })
}


fun Connection.putAndGetGeneratedKeyIntOrElse(@Language("SQL") sql: String, other: () -> Int): Int {
	return putAndGetGeneratedKeysOrElse(sql, { getInt(1) }, other)
}

fun Connection.putAndGetGeneratedKeyLongOrElse(@Language("SQL") sql: String, other: () -> Long): Long {
	return putAndGetGeneratedKeysOrElse(sql, { getLong(1) }, other)
}


inline fun <R> Connection.putAndGetGeneratedKeysOrElse(@Language("SQL") sql: String, result: ResultSet.() -> R, other: () -> R): R {
	createStatement().use { st ->
		
		if (st.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS) == 0) {
			return other()
		}
		
		st.generatedKeys.use {
			if (it.next()) {
				return it.result()
			}
			throw SQLException("Update has empty generate keys")
		}
	}
}


// Prepared fetch

inline fun <R> Connection.fetch(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, result: ResultSet.() -> R): R {
	prepareAddableStatement(sql).use { st ->
		st.setup()
		st.executeQuery().use {
			return it.result()
		}
	}
}

inline fun Connection.fetchIterate(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, action: ResultSet.() -> Unit) {
	fetch(sql, setup) {
		while (next()) {
			action()
		}
	}
}

inline fun <E> Connection.fetchList(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, transform: ResultSet.() -> E): List<E> {
	val list = mutableListOf<E>()
	fetchIterate(sql, setup) {
		list.add(transform())
	}
	return list
}

inline fun <K, V> Connection.fetchMap(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, transform: ResultSet.() -> Pair<K, V>): Map<K, V> {
	val map = mutableMapOf<K, V>()
	fetchIterate(sql, setup) {
		val (key, value) = transform()
		map[key] = value
		
	}
	return map
}

inline fun <K, V> Connection.fetchMapGroup(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, transform: ResultSet.() -> Pair<K, V>): Map<K, List<V>> {
	val map = mutableMapOf<K, MutableList<V>>()
	fetchIterate(sql, setup) {
		val (key, value) = transform()
		map.getOrPut(key) { mutableListOf() }.add(value)
	}
	return map
}

inline fun <R> Connection.fetchFirstOrElse(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, result: ResultSet.() -> R, other: () -> R): R {
	fetch(sql, setup) {
		return if (next()) result() else other()
	}
}

inline fun <R> Connection.fetchFirst(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, result: ResultSet.() -> R): R {
	return fetchFirstOrElse(sql, setup, result) {
		throw SQLException("Query has empty result")
	}
}

inline fun Connection.fetchExists(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Boolean {
	return fetchFirstOrElse(sql, setup, { true }, { false })
}

inline fun <R> Connection.fetchFirstMaybe(@Language("SQL") sql: String, result: ResultSet.() -> R): R? {
	return fetchFirstOrElse(sql, result, { null })
}

inline fun <R> Connection.fetchFirstMaybe(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, result: ResultSet.() -> R): R? {
	return fetchFirstOrElse(sql, setup, result, { null })
}

// Put prepared

inline fun Connection.put(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Int {
	val rows = putMaybe(sql, setup)
	if (rows == 0) {
		throw SQLException("Update has not made any changes")
	}
	return rows
}

inline fun Connection.putMaybe(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Int {
	prepareAddableStatement(sql).use {
		it.setup()
		return it.executeUpdate()
	}
}

inline fun Connection.putOrElse(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, other: () -> Unit) {
	if (0 == putMaybe(sql, setup)) {
		other()
	}
}

inline fun Connection.putAndGetGeneratedKeyInt(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Int {
	return putAndGetGeneratedKeysOrElse(sql, setup, { getInt(1) }, { throw SQLException("Update has not made any changes") })
}

inline fun Connection.putAndGetGeneratedKeyLong(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Long {
	return putAndGetGeneratedKeysOrElse(sql, setup, { getLong(1) }, { throw SQLException("Update has not made any changes") })
}


inline fun Connection.putAndGetGeneratedKeyIntMaybe(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Int? {
	return putAndGetGeneratedKeysOrElse(sql, setup, { getInt(1) }, { null })
}

inline fun Connection.putAndGetGeneratedKeyLongMaybe(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit): Long? {
	return putAndGetGeneratedKeysOrElse(sql, setup, { getLong(1) }, { null })
}


inline fun Connection.putAndGetGeneratedKeyIntOrElse(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, other: () -> Int): Int {
	return putAndGetGeneratedKeysOrElse(sql, setup, { getInt(1) }, other)
}

inline fun Connection.putAndGetGeneratedKeyLongOrElse(@Language("SQL") sql: String, setup: AddablePreparedStatement.() -> Unit, other: () -> Long): Long {
	return putAndGetGeneratedKeysOrElse(sql, setup, { getLong(1) }, other)
}


inline fun <R> Connection.putAndGetGeneratedKeysOrElse(
	@Language("SQL") sql: String,
	setup: AddablePreparedStatement.() -> Unit,
	result: ResultSet.() -> R,
	other: () -> R
): R {
	prepareAddableStatement(sql, Statement.RETURN_GENERATED_KEYS).use { st ->
		st.setup()
		
		if (st.executeUpdate() == 0) {
			return other()
		}
		
		st.generatedKeys.use {
			if (it.next()) {
				return it.result()
			}
			throw SQLException("Update has empty generate keys")
		}
	}
}
